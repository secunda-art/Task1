def list_to_pow(nums, power):
    """ Возводит все элементы списка целых чисел в целую степень
    
    Аргументы:
        - nums:list - список целых чисел
        - pow:int - степень, в которую необходимо возвести числа
    
    Возвращает:
        - list целых чисел

    Указания: 
        - используйте map и lambda
        - авторское решение занимает 40 символов
    """
    # map применяет функцию lambda возведения в степень ко всем элементам nums
    return list(map(lambda x: pow(x, power), nums))


def naive_encoder(n):
    """ Вычисляет n + nn + nnn для данного n. Например,
        для n = 10 вычисляет 10 + 1010 + 101010
    
    Аргументы:
        - n:int - неотрицательное целое число

    Возвращает:
        - int

    Указания:
        - используйте преобразование типов int и str друг в друга
        - авторское решение занимает 40 символов
    """
    #число n прибавляется к числу nn, которое мы получили из строчки + nnn так же из строчки
    out = (n + int(str(n)*2) + int(str(n)*3))
    return out


def fibonacci_nth(n):
    """ Вычисляет n-е число Фибоначчи
    
    Аргументы:
        - n:int - натуральное число от 1 до 10**5
    
    Возвращает:
        - int

    Указания:
        - не нужно хранить в памяти всю последовательность чисел
        - используйте множественное присваивание, например: a, b = 1, 1
        - авторское решение занимает 6 строк
    """
    a, b = 0, 1
    while n != 0:
        n -= 1
        a, b = b, a+b
    return a


def clip_list(objl, a_min, a_max):
    """ Проверяет, что объекты списка objl находятся в диапазоне значений [a_min, a_max]
        Если элемент списка меньше a_min, то его значение меняется на a_min.
        Если элемент списка больше a_max, то его значение меняется на a_max.

    Аргументы:
        - objl:list - список объектов для которых определен оператор <
        - a_min - объект того же типа, что элементы списка objl
        - a_max - объект того же типа, что элементы списка objl, a_min <= a_max

    Возвращает:
        - list: список, элементы которого находятся в диапазоне значений [a_min, a_max]

    Указания:
        - Используйте функции min и max
        - способ 1:
            - используйте list comprehension
            - авторское решение занимает 48 символа
        - способ 2:
            - функцию map и lambda-функцию
            - авторское решение занимает 59 символа
    """
    for i in [objl]:
        if i < a_min:
            i = a_min
        if i > a_max:
            i = a_max
    objl.append(i)
    return objl
    #return [max(a_min, min(x, a_max)) for i in objl]    


def input_to_list():
    """ Запрашивает список целых чисел через стандартный поток в формате
        "n1, n2, n3, ..., ni", i >= 0, и преобразует его в список целых чисел

    Аргументы: отсутствуют

    Возвращает:
        - list: список целых чисел

    Указания:
        - гарантируется, что вводятся корректные данные
        - обратите внимание на случаи, когда вход подается 0 и 1 число
        - используйте функцию input и метод split типа str
        - используйте оператор in для поиска по строке
        - авторское решение занимает 6 строк
    """
    a = input()
    b = a.split(', ')
    c = []
    for i in b:
        c.append(int(i))
    return c


def income_by_client(records):
    """ Подсчитывает поступления от каждого клиента по списку всех поступлений

    Аргументы:
        - records: список (list) кортежей (tuple). Каждый кортеж состоит из
                   двух элементов: (имя клиента: str, сумма: int). Например:
                   [('John', 100), ('Anna', 251), ('John', 50)]

    Возвращает:
        - dict: словарь, ключ которого есть имя клиента, а значение - сумма 
                поступлений от этого клиента. Например:
                {'John': 150, 'Anna': 251}

    Указания:
        - авторское решение занимает 7 строк
    """
    diction = {} #так обозначается словарь
    for name, money in records:
        if name in diction:
            diction[name] += money
        else:
            diction[name] = money 
    return diction
    



def add_prefix(str_list, pref):
    """ Добавляет префикс к каждой строке из списка. Строки, которые уже начинаются
        с нужного префикса, не изменяются

    Аргументы:
        - str_list:list - список строк
        - pref:str - префикс, который необходимо добавить

    Возвращает:
        - list: копию исходного списка, содержаший модифицированные строки. Строки
                должны располагаться в том же порядке, что и в исходном списке

    Указания:
        - используйте метод startswith типа str
        - способ 1: 
            - используйте комбинацию функции map и lambda-функции
            - авторское решение занимает 85 символа
        - способ 2:
            - используйте list comprehension
            - авторское решение занимает 74 символа
    """
    out = []
    for i in str_list:
        if i.startswith(pref):
            out.append(i)
        else:
            out.append(pref+i)
    return out


def hide_secrets(recodrs):
    """ Возвращает копию списка строк recodrs, из которого удалены все строки,
        содержащие `secret` в любой комбинации строчных и заглавных символов
        (например, `sEcReT` не должен проходить фильтр)

    Аргументы:
        - recodrs:list - список строк

    Возвращает:
        - list: список строк, прошедших фильтрацию, в том же порядке, в каком
                они располагались в исходном списке

    Указания:
        - используйте встроенную функцию filter в комбинации с lambda-функцией
        - используйте метод casefold или метод lower класса str
        - авторское решение занимает 68 символа
    """
    out = []
    for i in recodrs:
        if 'secret' not in i.lower():
            out.append(i)
    print (out)
    return out


def is_same_type(objlist):
    """ Возвращает True, если все объекты списка являются объектами одного типа
        и False, если список содержит хотя бы два объекта разных типов.

    Аргументы:
        - objlist:list - список объектов

    Возвращает:
        - bool

    Указания:
        - используйте встроенную функцию type
        - авторское решение занимает 39 символов
    """
    a = type (objlist[0])
    for i in objlist:
        if type(i) != a:
            return False
    return True


def file_to_str_list(path):
    """ Возвращает содержимое текстового файла в виде списка строк.
        Каждая строка соответствует строке файла

    Аргументы:
        - path: полный путь до файла. Гарантируется, что файл существует

    Возвращает:
        - list: список строк файла

    Указания:
        - используйте функцию open, чтобы открыть файл
        - файловый объект - итерируемый. Итерирование происходит по строкам
        - авторское решение занимает 35 символов
    """
    linelist = []
    with open(path, 'r') as f:
        for line in f:
            linelist.append(line)
    return linelist